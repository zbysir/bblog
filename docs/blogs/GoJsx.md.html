<!DOCTYPE html><html lang="zh"><head><meta charSet="UTF-8"/><title>bysir 的博客</title><link href="/tailwind.css" rel="stylesheet"/><link rel="stylesheet" href="/blog/tailwind.css"/></head><body><div class="container mx-auto p-6 bg-white rounded-xl shadow-md flex items-center space-x-4">Hello: bysir</div><div class="container mx-auto p-6 bg-white flex"><div class="prose"><h2> GoJsx.md </h2><div><h1>gojsx</h1>

<p>Render React Jsx by Golang</p>

<p>使用 Go 渲染 Jsx。</p>

<p>Jsx 优势：</p>

<ul>
<li>实际上就是 js 代码，它是图灵完备的。</li>
<li>和 js 生态行为一致，不用学习更多语法。</li>
</ul>

<h2>例子</h2>

<p>编写 jsx 文件（或者 tsx）</p>

<pre><code class="language-jsx">import App from &quot;./App&quot;;

export default function Index(props) {
  return &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charSet=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link href=&quot;https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;App {...props}&gt;&lt;/App&gt;
  &lt;/body&gt;
  &lt;/html&gt;
}
</code></pre>

<pre><code class="language-go">package jsx

func TestJs(t *testing.T) {
	j, err := NewJsx()
	if err != nil {
		t.Fatal(err)
	}

	s, err := j.Render(&quot;./test/Index&quot;, map[string]interface{}{&quot;li&quot;: []int64{1, 2, 3, 4}})
	if err != nil {
		t.Fatal(err)
	}

	t.Logf(&quot;%+v&quot;, s)
}
</code></pre>

<h2>实现原理</h2>

<p>由于 Jsx 实际上就是 js 代码，如果要渲染 jsx，则需要在 Golang 中运行 js 代码，感谢伟大的 goja 库。</p>

<p>由于 goja 只支持 es5.1 语法，高级语法如 TS、ES6 则需要通过 babel 转换，babel 提供一个浏览器运行版本，刚好 goja 可以运行它。</p>

<p>将编译之后的 jsx 交给 goja 运行，能得到一个虚拟节点树，然后再由 golang 进行渲染得到 HTML。</p>

<h2>性能</h2>

<p>babel 是十分慢的，相信开发过前端的朋友都深有体会，但我们可以通过预编译来减少影响。除此之外运行编译好的 jsx 模板是很快的（ goja 本身很快），不必担心。</p>

<p>另外 这个项目应该是性能不敏感的，我想用它来生成静态文件（例如制作官网与博客），而不是实时渲染。</p>

<h2>FQA</h2>

<h3>支持 React 的 UI 库吗？ 如 ant</h3>

<p>不支持，由于库的复杂依赖关系，会出现意料之外的错误，也会导致加载变得很慢。</p>

<p>如果你非要使用，尝试使用 webpack 将依赖打包成独立的 js 文件，然后引入它（待测试）。</p>
</div></div></div><div></div></body></html>